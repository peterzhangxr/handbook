# 16 | WebAPI：setTimeout是如何实现的？

渲染进程中需要异步处理的回调函数才会添加的消息队列中

事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程

#### 使用 setTimeout 的一些注意事项

* 1. 如果当前任务执行时间过久，会影响定时器任务的执行
* 2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒，所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。
* 3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
* 4. 延时执行时间有最大值
* 5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉;如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销


# 17 | WebAPI：XMLHttpRequest是怎么实现的？

#### 回调函数 VS 系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。

上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为**同步回调**。

我们把这种回调函数在主函数外部执行的过程称为**异步回调**。

消息队列和主线程循环机制保证了页面有条不紊地运行。

异步回调是指回调函数在主函数之外执行，一般有两种方式：

* 第一种是把异步函数做成一个任务，添加到信息队列尾部；
* 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。

一切准备就绪之后，就可以调用xhr.send来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。 

#### XMLHttpRequest 使用过程中的“坑”

# 18 | 宏任务和微任务：不是所有任务都是一个待遇
#### 宏任务

* 渲染事件（如解析 DOM、计算布局、绘制）；
* 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
* JavaScript 脚本执行事件；
* 网络请求完成、文件读写完成事件。

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

#### 微任务

第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。


为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。

首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。MutationObserver 采用了“异步 + 微任务”的策略。

# 19 | Promise：使用Promise，告别回调函数