# 01 ｜ Chrome架构：仅仅打开了一个页面，为什么有4个进程
多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
* 1.进程中的任意一线程执行出错，都会导致整个进程的崩溃。
* 2.线程之间共享进程中的数据。
* 3.当一个进程关闭之后，操作系统会回收进程所占用的内存。
* 4.进程之间的内容相互隔离。

Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信

为什么多进程架构就能用安全沙箱？ 评论区有人问过，答案如下：如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。（也就是说浏览器至少需要一个进程，并且它是拥有最高权限的。如果要有安全沙箱，浏览器至少需要两个进程，一个当主进程，一个使用安全沙箱

仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标

理解：以前是每个页面需要若干进程完成各自的工作，现在是将各个页面通用的功能（视频、网络、渲染等）发布为系统服务，页面在需要的时候与相应的服务通信完成需要的功能。这起码把进程间的耦合从页面中分离出去了。


即使是如今的多进程架构，我偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，请问这是什么原因呢
作者回复: 是这样的，通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。

Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。

直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。

所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。

为什么要让他们跑在一个进程里面呢？

因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

# 02｜TCP协议: 如何保证页面文件能被完成送达浏览器？

#### UDP
IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号爸数据包分发给正确的程序。在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。


#### TCP
TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:
* 对于数据包丢失的情况，TCP 提供重传机制；
* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。
* 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

第一次：客户端给服务端发送一个带有SYN标志的数据包 第二次：服务端给客户端发送带有SYN和ACK标志得数据包 第三次：客户端给服务端发送带有ACK标志的数据包 为什么是三次？ 一次肯定不行，客户端发过去之后服务端无响应，客户端就不知道是否可以进行数据数据传递 两个也不行，比如客户端给服务端说我要进行传递数据，服务端说可以传递，两个握手完成。如果没有第三次客户端的确认，服务端不知道客户端是否收到它允许传递的信号，所以两次也不行。

* 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
TCP通过三次握手建立连接，也就是发送三次数据包。 如果传输的是大文件，会被拆分为好多小数据包。这些数据包到接收端，接收端会按照TCP头中的顺序将这些数据包排序，保证形成完整数据。如果一定时间内没有接收到数据包，会触发发送端的重传机制。等到重传之后才开始渲染。正常渲染是接受到content-type请求头开始渲染。 通过四次挥手断开连接。

* 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

HTTP协议和TCP协议都是TCP/IP协议簇的子集。
HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。
请求方要发送的数据包，在应用层加上HTTP头以后会交给传输层的TCP协议处理，应答方接收到的数据包，在传输层拆掉TCP头以后交给应用层的HTTP协议处理。建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析HTTP报文。

1. 浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？
   端口一样的，网络进程知道每个tcp链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。

2. TCP传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？
    接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）

3. http 和 websocket都是属于应用层的协议吗？
都是应用层协议，而且websocket名字取的比较有迷惑性，其实和socket完全不一样，可以把websocket看出是http的改造版本，增加了服务器向客户端主动发送消息的能力。

4. 关于 "数据在传输的过程中有可能会丢失或者出错"，丢失的数据包去哪里了？凭空消失了吗？出错的数据包又变成啥了？ 为什么会出错？
比如网络波动，物理线路故障，设备故障，恶意程序拦截，网络阻塞等等

# 03 ｜ Http请求流程：为什么很多站点第二次速度打开会很快？

而 HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

涉及到浏览器缓存机制，强缓存和协商缓存

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
 http/1.1 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！ 但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！ 不过http2是可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接

 当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。

 Cache-Control、Expires用于设置缓存过期时间。 

 Cache-Control响应头中常用字段的具体含义： 
 * 1）、max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒； 
 * 2）、s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言； 
 * 3）、public：指示响应可被任何缓存区缓存； 
 * 4）、private：只能针对个人用户，而不能被代理服务器缓存； 
 * 5）、no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
 *  6）、no-store：禁止一切缓存（这个才是响应不被缓存的意思）。

Cache-Control的优先级高于Expires。 

Etag是属于HTTP 1.1属性，它是由服务器生成返回给前端。

ETag 实体标签: 一般为资源实体的哈希值。
当你第一次发起HTTP请求时，服务器会返回一个Etag，并在你第二次发起同一个请求时，客户端会同时发送一个If-None-Match，而它的值就是Etag的值（此处由发起请求的客户端来设置）。然后，服务器会比对这个客服端发送过来的Etag是否与服务器的相同，如果相同，就将If-None-Match的值设为false，返回状态为304，客户端继续使用本地缓存，服务器不返回数据。
如果不相同，就将If-None-Match的值设为true，返回状态为200，客户端重新解析服务器返回的数据。 

Last-Modified表示响应资源在服务器最后修改时间。 
1）Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间； 
2）如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存； 
3）有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Etag的优先级高于Last-Modified。


##### 如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？

1.并发请求过多（大于6），TCP连接进入等待状态
2.资源大，下载时间过长 
3.对于一些资源的重复请求，TCP连接没有connection=keep-alive, 消耗连接时间 
4.网络慢、连接超时 
5.网络传输丢包，需要不断重传