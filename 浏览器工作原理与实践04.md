# 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

#### 执行上下文
* 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
* 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
* 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

#### 调用栈

调用栈就是用来管理函数调用关系的一种数据结构

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

console.trace()查看调用栈或者chrome源码中的call stack

这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。

为什么使用定时器可以解决栈移除问题？ function foo() { setTimeout(foo, 0) } foo() 像setTimeout 、setInterval Promise 这样的全局函数不是js 的一部分，而是webapi 部分。 当遇到webApi 时，会将其回调函数(foo)交给web apis 处理，此时 调用栈 中foo 函数执行完毕，出栈，栈为空； 回调函数会被发送到任务队列中，等待event loop 事件循环将其捞出 重新放入到堆栈中 .... 参考：https://juejin.im/post/5d2d146bf265da1b9163c5c9#heading-15

 * 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
 * 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
 * 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
 * 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

# 09 | 块级作用域：var缺陷以及为什么要引入let和const？

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

#### JavaScript 是如何支持块级作用域的

现在你知道了 ES 可以通过使用 let 或者 const 关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”


* 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
* 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。
* 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。


沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。

```
let myname= '极客时间'
{
	console.log(myname)
	let myname= '极客邦'
}
```
这里涉及到一个临时性死区（TDZ）的知识； 变量在上下文的存在过程分3个阶段：创建、初始化、赋值； 创建：会在环境上下文创建一个该名字的变量，并为其分配内存空间； 初始化：将该变量初始化为undefined； 赋值：为该变量赋值； 其中，在编译时，会完成创建与初始化，也就是压栈操作； 但是let/const声明的变量只会在环境中创建该变量，并不会进行后面的初始化，在这创建与初始化中间这段时间是无法读取变量的。 这段“时间”叫做临时性死区； 这道题，因为函数内部有myname变量会被提升，但在赋值前就读取，所以会报错

# 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

#### 作用域链
其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。

#### 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。


在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。